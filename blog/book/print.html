<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>thoughtassault-blog</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="hello.html">Hello</a></li><li class="chapter-item expanded affix "><li class="part-title">Learning Rust</li><li class="chapter-item expanded "><a href="project_1.html"><strong aria-hidden="true">1.</strong> Message passing between a client and a server</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Improvement on message passing: Requesting arbitrary data</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">thoughtassault-blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hello"><a class="header" href="#hello">Hello</a></h1>
<p>My name is Dora, and I am a software developer from Turkey.</p>
<h2 id="education"><a class="header" href="#education">Education</a></h2>
<h3 id="undergrad"><a class="header" href="#undergrad">Undergrad</a></h3>
<p>I graduated with a BSc in <strong>Computer Science</strong> and Minor in <strong>Philosophy</strong> from <strong>Sabanci University</strong> in January 2023.</p>
<h2 id="work-experience"><a class="header" href="#work-experience">Work Experience</a></h2>
<h3 id="nlp-intern--yazi-ai-summer-2021"><a class="header" href="#nlp-intern--yazi-ai-summer-2021"><strong>NLP INTERN</strong> @ <strong>YAZI AI</strong> (Summer 2021)</a></h3>
<p>This project aimed to be a pioneer in Turkish NLP, as it was one of the first works on Turkish Financial Sentiment Analysis. I built scrapers for financial news websites and stock market movements. Then I tried to apply NER to the data I collected. The internship ended due to time constraints before I could complete the project.
I worked with Python.</p>
<p>I was very inexperienced and mostly confused. I was very dependent on my supervisor and she was quite busy, so things did not really go as I wanted them to go.</p>
<h3 id="visiting-researcher-intern--the-university-of-kent-summer-2022"><a class="header" href="#visiting-researcher-intern--the-university-of-kent-summer-2022"><strong>Visiting Researcher Intern</strong> @ <strong>The University of Kent</strong> (Summer 2022)</a></h3>
<p>At Kent, I was responsible with implementing a tool to collect data about DDoS protection adoption across the internet. I used Go, MongoDB and GCC. 
Since the tool was meant to scan the a huge number of domains weekly, it had to be performant. I benchmarked several approaches and libraries.</p>
<p>This internship made me discover my interest for programming languages. I love learning new programming syntax, semantics and paradigms.</p>
<h3 id="mobile-developer--upcarta"><a class="header" href="#mobile-developer--upcarta"><strong>Mobile developer</strong> @ <strong>upcarta</strong></a></h3>
<p><a href="https://www.upcarta.com/">Upcarta</a> is a platform for discovering, organizing and sharing content. Its killer feature is gathering scattered content recommendations, curations and collections from all around the web.</p>
<p>For the past year, I have been developing the mobile app of upcarta. We use Flutter.</p>
<p>I learned Flutter all by myself and taught the rest of the team on the go. I had to make the architectural and stylistic decisions, and the Flutter framework didn't/doesn't really have many best practices and idiomatic ways to guide us. It was quite a challenge.</p>
<p>Upcarta Mobile will be on app stores soon. I can share a test link if you want to try upcarta.</p>
<h2 id="today"><a class="header" href="#today">Today</a></h2>
<p>Working on Upcarta, learning Rust. I am open to Rust developer positions.</p>
<p>This will also be a blog for me to organize and share my learning process/progress, food for thought and thought for food.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-message-passing-between-a-client-and-a-server"><a class="header" href="#1-message-passing-between-a-client-and-a-server">1. Message passing between a client and a server</a></h1>
<p>I am trying to implement simple message-passing channels in Rust. I want to share/log my learning progress. I think it will be fun to return to it in some months/years.</p>
<p>Note: I am a complete beginner to Rust and haven't dealt with this sort of concurrency before.</p>
<p>The task is simple: I will have two channels running on different threads or running as concurrent processes. 
One of them will be the client, asking for the amount of ice cream the server has. Client's actions can be triggered by command line inputs.</p>
<p>The server will tell the client how much ice cream it has. The ice cream is 1kg to begin with, and melts by 10g each second. Bonus: each question can decrease the amount of ice cream by 20g. This will force the server to implement some kind of concurrent operation handling.</p>
<h2 id="first-try"><a class="header" href="#first-try">First try</a></h2>
<p>I read <a href="https://tokio.rs/tokio/tutorial/channels">tokio docs</a>. I initialize the channel, and pass the transmitter and receiver to the tasks I spawn in the main thread (which felt intuitive). But the program immediately ends. No messages after the initial &quot;Let's go!&quot; are printed.</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    println!(&quot;Let's go!&quot;);
    // Create the channel
    let (tx, rx) = mpsc::channel(8);
    // Spawn the server task.
    tokio::spawn(run_server(rx));

    // Spawn the client task.
    tokio::spawn(run_client(tx));
}

async fn run_server(mut rx: mpsc::Receiver&lt;String&gt;) {
    println!(&quot;running server&quot;);
    while let Some(message) = rx.recv().await {
        println!(&quot;GOT = {}&quot;, message);
    }
}

async fn run_client(tx: mpsc::Sender&lt;String&gt;) {
    println!(&quot;sending from first handle&quot;);
    // wait for 2 seconds
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    println!(&quot;woke up from sleep&quot;);

    tx.send(&quot;sending from first handle&quot;.to_owned())
        .await
        .unwrap();
}</code></pre></pre>
<p>I think the problem with this was that my program was not waiting for any of the tasks I spawned. It just started the threads, and there was nothing else to do, so it returned.</p>
<h2 id="second-attempt"><a class="header" href="#second-attempt">Second attempt</a></h2>
<p>Run the server in the main thread and wait for it to complete. This works, but I think I am blocking the main thread with the server.</p>
<p>Also I got the intuition that once the function owning the transmitter (client) returns, it is dropped, so the channel is closed.</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    println!(&quot;Let's go!&quot;);
    let (tx, rx) = mpsc::channel(8);
    // Spawn the client task.
    tokio::spawn(run_client(tx));

    // the server is running, but it blocks
    _run_server(rx).await;
}

// we do not use this function in this version
async fn _run_server(mut rx: mpsc::Receiver&lt;String&gt;) {
    println!(&quot;running server&quot;);
    while let Some(msg) = rx.recv().await {
        println!(&quot;received: {:?}&quot;, msg);
    }
}

async fn run_client(tx: mpsc::Sender&lt;String&gt;) {
    // wait for 2 seconds
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    let msg = String::from(&quot;Hello ice cream guy&quot;);
    tx.send(msg).await.expect(&quot;can not send user on channel&quot;);
}</code></pre></pre>
<h2 id="third-attempt"><a class="header" href="#third-attempt">Third attempt</a></h2>
<p>I spawn a new task for the server and wait for it to complete. This works, but I don't really understand why. I don't know if I am blocking the main thread as well. I also feel like there is a cleaner way to do this. Added understanding this thoroughly to my task.</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    println!(&quot;Let's go!&quot;);
    let (tx, rx) = mpsc::channel(8);
    // Spawn the client task.
    tokio::spawn(run_client(tx));

    // Spawn the server task in a way it doesnt block the main thread
    tokio::spawn(async move {
        run_server(rx).await;
    })
    .await
    .unwrap();
}

// we do not use this function in this version
async fn run_server(mut rx: mpsc::Receiver&lt;String&gt;) {
    println!(&quot;running server&quot;);
    while let Some(msg) = rx.recv().await {
        println!(&quot;received: {:?}&quot;, msg);
    }
}

async fn run_client(tx: mpsc::Sender&lt;String&gt;) {
    // wait for 2 seconds
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

    let msg = String::from(&quot;Hello ice cream guy&quot;);

    tx.send(msg).await.expect(&quot;can not send user on channel&quot;);
}</code></pre></pre>
<p><strong>Minor update:</strong> I confirmed my hunch that when the function using the transmitter returns, the channel is closed.</p>
<p>While trying to learn about this, I read <a href="https://doc.rust-lang.org/book/ch16-02-message-passing.html">something on the Rust book</a> that excited me:</p>
<blockquote>
<p>One increasingly popular approach to ensuring safe concurrency is message passing, where threads or actors communicate by sending each other messages containing data.
Here’s the idea in a slogan from the Go language documentation: <em>“Do not communicate by sharing memory; instead, share memory by communicating.”</em></p>
</blockquote>
<p>I love #golang, and seeing a wink to its docs made my day.</p>
<h2 id="fourth-attempt"><a class="header" href="#fourth-attempt">Fourth attempt</a></h2>
<p>I did some improvements and kinda nailed the task. The #rustlang discord community helped me.</p>
<p>I learned from them a couple of things:</p>
<ol>
<li>
<p>I should await the tasks, so that the program will wait for them to complete. In order for them not to block the main thread, I should spawn the tasks, and await the futures returned by the tasks somewhere else. Any code that will run in the main thread should run in between.</p>
</li>
<li>
<p>I could also use <code>join!</code>, but that's overkill because it's used for lazy futures, and tokio starts the tasks immediately. Therefore awaiting them in series is enough and idiomatic.</p>
</li>
</ol>
<p>I didn't understand when to use <code>join!</code> exactly, but I understand what's going on with my code.</p>
<p>Here is what I did with what I've learnt:</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    println!(&quot;Let's go!&quot;);
    let (tx, rx) = mpsc::channel(8);

    let client = tokio::spawn(run_client(tx));
    let server = tokio::spawn(run_server(rx));

    client.await.unwrap();
    server.await.unwrap(); // The main thread will not return until server returns. 
}</code></pre></pre>
<p><strong>Receiving responses:</strong></p>
<p>I wanted the clients to be able to send requests and receive responses to those. I accidentally asked GPT to tell me how receive responses from the server so it recommended me to use oneshot channels. So I created a ClientRequest to be sent.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct ClientRequest {
    message: String,
    tx: oneshot::Sender&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>The server:</strong>
Ice cream melts. I added this to see how data processing within the server could be a part of the whole message exchanging program. I had seen the <code>interval.tick</code> before, but Copilot completed the piece of code that ticks the timer. I will learn about how that works.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn run_server(mut rx: mpsc::Receiver&lt;ClientRequest&gt;) {
    println!(&quot;SERVER; I will give one person some ice cream!&quot;);
    let mut ice_cream_amount = 50;
    let mut interval = time::interval_at(
        Instant::now() + Duration::from_secs(1),
        time::Duration::from_secs(1),
    );

    loop {
        tokio::select! {
            _ = interval.tick() =&gt; {
                if ice_cream_amount &lt; 10 {
                    println!(&quot;SERVER; no more ice cream!&quot;);
                    return;
                }
                ice_cream_amount -= 10;
            }
            Some(ClientRequest { message, tx }) = rx.recv() =&gt; {
                println!(&quot;SERVER; received: {:?}&quot;, message);

                let response = format!(&quot;Here is your ice cream! I have {ice_cream_amount} left!&quot;);
                tx.send(response).unwrap();
            }
            else =&gt; {
                println!(&quot;SERVER; I don't know what's happening here!&quot;);
                break;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Client:</strong></p>
<p>Every two seconds, the client will ask the server for ice cream, and report how much ice cream is left. It creates a oneshot channel and passes it to the server for an answer. It is blocked until the server responds.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn run_client(tx: mpsc::Sender&lt;ClientRequest&gt;) {
    loop {
        tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
        if tx.is_closed() {
            println!(&quot;CLIENT; Ice cream guy is gone! I guess I will go home now.&quot;);
            return;
        }
        let (response_tx, response_rx) = oneshot::channel();
        let new_msg = ClientRequest {
            message: String::from(&quot;Hello ice cream guy, give me ice cream!&quot;),
            tx: response_tx,
        };
        tx.send(new_msg)
            .await
            .expect(&quot;can not send user on channel&quot;);

        let answer = response_rx.await.unwrap();
        println!(&quot;CLIENT; I knew you loved me!: {:?}&quot;, answer);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>I might work on a more complicated implementation by adding the following:</p>
<ul>
<li>There are more than one clients, and each time the clients ask for ice cream, the amount of ice cream decreases.</li>
<li>The client's are not blocked when they are waiting for a response from the server.</li>
</ul>
<p>Another insight I gained due to the help of a Rust developer was that the Go idiom I mentioned was more than a best practice in Rust. The compiler has strict constraints on how data can be modified by different threads.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
